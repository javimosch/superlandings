<script>
  const { createApp } = Vue;

  createApp({
    data() {
      return {
        // Auth & Organizations
        authInfo: { isAdmin: false, user: null, organizations: [], rights: [] },
        organizations: [],
        allOrganizations: [],
        currentOrganization: null,
        showOrgSwitcher: false,
        showMobileMenu: false,
        
        // Landings
        landings: [],
        showAddModal: false,
        showEditModal: false,
        newLanding: { name: '', slug: '', type: 'html', domains: [], content: '<!DOCTYPE html>\n<html>\n<head>\n  <title>New Landing</title>\n</head>\n<body>\n  <h1>Hello World!</h1>\n</body>\n</html>' },
        selectedEjsFiles: [],
        selectedEjsZip: null,
        editSelectedEjsFiles: [],
        editSelectedEjsZip: null,
        editingLanding: null,
        addEditor: null,
        editEditor: null,
        
        // Domains
        editingDomains: null,
        showDomainsModal: false,
        showAdminDomainsModal: false,
        adminConfig: { domains: [], published: false, traefikConfigFile: '' },
        
        // Organizations Modal
        showOrganizationsModal: false,
        newOrgName: '',
        editingOrg: null,
        allUsers: [],
        newUserEmail: '',
        newUserPassword: '',
        showAddUserToOrg: null,
        addUserEmail: '',
        availableRights: [],
        
        // User Rights Modal
        showUserRightsModal: false,
        editingUserRights: null,
        
        // Move Landing Modal
        showMoveModal: false,
        movingLanding: null,
        moveTargetOrgId: '',
        
        // Versions Modal
        showVersionsModal: false,
        versionLanding: null,
        versions: [],
        newVersionDescription: '',
        showVersionPreviewModal: false,
        previewingVersion: null,
        versionPreviewContent: '',
        
        // Confirmation dialogs
        showRollbackConfirm: false,
        showDeleteConfirm: false,
        confirmingVersion: null,
        
        // Version editing
        editingVersionDescription: false,
        editingVersionTag: false,
        editingVersionId: null,
        tempDescription: '',
        tempTag: '',
        
        // Diff Modal
        showDiffModal: false,
        diffData: null,
        collapsedFiles: {},
        
        // HTML View Modal
        showVersionHtmlModal: false,
        viewingHtmlVersion: null,
        versionHtmlContent: '',
        
        // Audit Modal
        showAuditModal: false,
        auditLanding: null,
        auditEntries: [],
        auditTotal: 0,
        auditHasMore: false,
        auditOffset: 0,
        
        // Preview Modal
        showPreviewModal: false,
        previewContent: '',
        previewMode: 'modal', // 'modal' or 'tab'
        
        // UI State
        loading: {},
        toasts: [],
        toastId: 0
      };
    },
    computed: {
      canCreate() {
        return this.authInfo.isAdmin || this.authInfo.rights.includes('landings:create');
      },
      canUpdate() {
        return this.authInfo.isAdmin || this.authInfo.rights.includes('landings:update');
      },
      canDelete() {
        return this.authInfo.isAdmin || this.authInfo.rights.includes('landings:delete');
      },
      canDomains() {
        return this.authInfo.isAdmin || this.authInfo.rights.includes('landings:domains');
      },
      allFilesCollapsed() {
        if (!this.diffData?.diffs) return false;
        return this.diffData.diffs.every((_, idx) => this.collapsedFiles[idx]);
      }
    },
    async mounted() {
      await this.loadOrganizations();
      this.initCurrentOrganization();
      await this.loadAuthInfo();
      await this.loadLandings();
      await this.loadAdminConfig();
      if (this.authInfo.isAdmin) {
        await this.loadAllUsers();
        await this.loadAvailableRights();
      }
    },
    methods: {
      // Toast notifications
      addToast(type, message, duration = 5000) {
        const id = ++this.toastId;
        this.toasts.push({ id, type, message });
        setTimeout(() => this.removeToast(id), duration);
      },
      removeToast(id) {
        const index = this.toasts.findIndex(t => t.id === id);
        if (index !== -1) this.toasts.splice(index, 1);
      },
      showError(message) { this.addToast('error', message); },
      showSuccess(message) { this.addToast('success', message, 3000); },
      
      // Close dropdowns on outside click
      closeDropdowns(e) {
        if (!e.target.closest('.relative')) {
          this.showOrgSwitcher = false;
        }
      },
      
      // Auth
      async loadAuthInfo() {
        try {
          const res = await fetch('/api/auth/me', { headers: this.getHeaders() });
          this.authInfo = await res.json();
        } catch (err) {
          console.error('Error loading auth info:', err);
        }
      },
      
      getHeaders() {
        const headers = {};
        if (this.currentOrganization) {
          headers['X-Organization-Id'] = this.currentOrganization.id;
        }
        return headers;
      },
      
      // Organizations
      async loadOrganizations() {
        try {
          const res = await fetch('/api/organizations');
          const orgs = await res.json();
          this.organizations = orgs;
          if (this.authInfo.isAdmin) {
            this.allOrganizations = orgs;
          }
        } catch (err) {
          this.showError('Error loading organizations: ' + err.message);
        }
      },
      
      initCurrentOrganization() {
        const savedOrgId = localStorage.getItem('currentOrganizationId');
        if (savedOrgId) {
          const org = this.organizations.find(o => o.id === savedOrgId);
          if (org) {
            this.currentOrganization = org;
            return;
          }
        }
        if (this.organizations.length > 0) {
          this.currentOrganization = this.organizations[0];
          localStorage.setItem('currentOrganizationId', this.currentOrganization.id);
        }
      },
      
      switchOrganization(org) {
        this.currentOrganization = org;
        localStorage.setItem('currentOrganizationId', org.id);
        this.showOrgSwitcher = false;
        this.loadLandings();
        this.showSuccess(`Switched to ${org.name}`);
      },
      
      getOrgName(orgId) {
        const org = this.organizations.find(o => o.id === orgId);
        return org ? org.name : 'Unknown';
      },
      
      // Landings
      async loadLandings() {
        try {
          const res = await fetch('/api/landings', { headers: this.getHeaders() });
          this.landings = await res.json();
        } catch (err) {
          this.showError('Error loading landings: ' + err.message);
        }
      },
      
      async loadAdminConfig() {
        try {
          const res = await fetch('/api/admin-config');
          this.adminConfig = await res.json();
        } catch (err) {
          console.error('Error loading admin config:', err);
        }
      },
      
      formatDate(dateStr) {
        return new Date(dateStr).toLocaleDateString();
      },
      
      closeAddModal() {
        this.showAddModal = false;
        this.newLanding = { name: '', slug: '', type: 'html', domains: [], content: '<!DOCTYPE html>\n<html>\n<head>\n  <title>New Landing</title>\n</head>\n<body>\n  <h1>Hello World!</h1>\n</body>\n</html>' };
        this.selectedEjsFiles = [];
        this.selectedEjsZip = null;
        if (this.addEditor) {
          this.addEditor.toTextArea();
          this.addEditor = null;
        }
      },
      
      async addLanding() {
        try {
          const formData = new FormData();
          formData.append('name', this.newLanding.name);
          formData.append('slug', this.newLanding.slug);
          formData.append('type', this.newLanding.type);
          if (this.currentOrganization) {
            formData.append('organizationId', this.currentOrganization.id);
          }
          const domains = this.newLanding.domains
            .filter(d => typeof d === 'string' ? d.trim() : d.domain && d.domain.trim())
            .map(d => typeof d === 'string' ? { domain: d.trim(), published: false } : d);
          formData.append('domains', JSON.stringify(domains));

          if (this.newLanding.type === 'html') {
            formData.append('content', this.addEditor ? this.addEditor.getValue() : this.newLanding.content);
          } else if (this.newLanding.type === 'ejs') {
            if (this.selectedEjsZip) {
              formData.append('files', this.selectedEjsZip);
            } else if (this.selectedEjsFiles.length > 0) {
              this.selectedEjsFiles.forEach(file => formData.append('files', file));
            }
          } else if (this.$refs.fileInput?.files.length > 0) {
            Array.from(this.$refs.fileInput.files).forEach(file => formData.append('files', file));
          }

          const res = await fetch('/api/landings', { method: 'POST', body: formData, headers: this.getHeaders() });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          
          this.showSuccess('Landing created successfully!');
          this.closeAddModal();
          this.loadLandings();
        } catch (err) {
          this.showError('Error creating landing: ' + err.message);
        }
      },
      
      async editLanding(landing) {
        try {
          if (landing.type === 'html') {
            const res = await fetch(`/api/landings/${landing.id}/content`);
            const data = await res.json();
            this.editingLanding = { ...landing, content: data.content };
          } else {
            this.editingLanding = { ...landing };
          }
          this.showEditModal = true;
          this.$nextTick(() => { if (landing.type === 'html') this.initEditEditor(); });
        } catch (err) {
          this.showError('Error loading landing: ' + err.message);
        }
      },
      
      async saveEdit() {
        try {
          if (this.editingLanding.type === 'html') {
            const content = this.editEditor.getValue();
            const res = await fetch(`/api/landings/${this.editingLanding.id}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ content })
            });
            if (!res.ok) throw new Error('Failed to save');
          } else if (this.editingLanding.type === 'ejs') {
            const formData = new FormData();
            if (this.editSelectedEjsZip) {
              formData.append('files', this.editSelectedEjsZip);
            } else if (this.editSelectedEjsFiles.length > 0) {
              this.editSelectedEjsFiles.forEach(file => formData.append('files', file));
            } else {
              this.showError('Please select EJS files or a ZIP file to update');
              return;
            }
            const res = await fetch(`/api/landings/${this.editingLanding.id}`, { method: 'PUT', body: formData });
            if (!res.ok) throw new Error('Failed to save');
          }
          this.showSuccess('Changes saved successfully!');
          this.closeEditModal();
          this.loadLandings();
        } catch (err) {
          this.showError('Error saving: ' + err.message);
        }
      },
      
      closeEditModal() {
        this.showEditModal = false;
        this.editingLanding = null;
        this.editSelectedEjsFiles = [];
        this.editSelectedEjsZip = null;
        if (this.editEditor) { this.editEditor.toTextArea(); this.editEditor = null; }
      },
      
      async deleteLanding(id) {
        try {
          const res = await fetch(`/api/landings/${id}`, { method: 'DELETE' });
          if (!res.ok) throw new Error('Failed to delete');
          this.showSuccess('Landing deleted successfully!');
          this.loadLandings();
        } catch (err) {
          this.showError('Error deleting landing: ' + err.message);
        }
      },
      
      // Domains
      openDomainsModal(landing) {
        this.editingDomains = { ...landing, domains: landing.domains.map(d => ({ ...d })) };
        this.showDomainsModal = true;
      },
      closeDomainsModal() { this.showDomainsModal = false; this.editingDomains = null; },
      addDomain() { this.editingDomains.domains.push({ domain: '', published: false }); },
      removeDomain(index) { this.editingDomains.domains.splice(index, 1); },
      
      async publishSingleDomain(domain) {
        const loadingKey = this.editingDomains.id + '-' + domain;
        this.loading[loadingKey] = true;
        try {
          const res = await fetch(`/api/landings/${this.editingDomains.id}/domains/${encodeURIComponent(domain)}/publish`, { method: 'POST' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess(data.message);
          await this.loadLandings();
          const domainObj = this.editingDomains.domains.find(d => d.domain === domain);
          if (domainObj) domainObj.published = true;
        } catch (err) {
          this.showError('Error publishing domain: ' + err.message);
        } finally {
          this.loading[loadingKey] = false;
        }
      },
      
      async unpublishSingleDomain(domain) {
        const loadingKey = this.editingDomains.id + '-' + domain;
        this.loading[loadingKey] = true;
        try {
          const res = await fetch(`/api/landings/${this.editingDomains.id}/domains/${encodeURIComponent(domain)}/unpublish`, { method: 'POST' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess(data.message);
          await this.loadLandings();
          const domainObj = this.editingDomains.domains.find(d => d.domain === domain);
          if (domainObj) domainObj.published = false;
        } catch (err) {
          this.showError('Error unpublishing domain: ' + err.message);
        } finally {
          this.loading[loadingKey] = false;
        }
      },
      
      async saveDomains() {
        try {
          const domainPattern = /^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
          const domains = this.editingDomains.domains
            .filter(d => d.domain?.trim())
            .map(d => ({ domain: d.domain.trim(), published: d.published || false }));
          const invalidDomains = domains.filter(d => !domainPattern.test(d.domain));
          if (invalidDomains.length > 0) {
            this.showError('Invalid domain format: ' + invalidDomains.map(d => d.domain).join(', '));
            return;
          }
          const res = await fetch(`/api/landings/${this.editingDomains.id}/domains`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ domains })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('Domains updated successfully!');
          this.closeDomainsModal();
          this.loadLandings();
        } catch (err) {
          this.showError('Error updating domains: ' + err.message);
        }
      },
      
      async publishLanding(id) {
        this.loading[id] = true;
        try {
          const res = await fetch(`/api/landings/${id}/publish`, { method: 'POST' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess(data.message);
          this.loadLandings();
        } catch (err) {
          this.showError('Error publishing: ' + err.message);
        } finally {
          this.loading[id] = false;
        }
      },
      
      async unpublishLanding(id) {
        this.loading[id] = true;
        try {
          const res = await fetch(`/api/landings/${id}/unpublish`, { method: 'POST' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess(data.message);
          this.loadLandings();
        } catch (err) {
          this.showError('Error unpublishing: ' + err.message);
        } finally {
          this.loading[id] = false;
        }
      },
      
      // Admin Config
      async saveAdminDomains() {
        try {
          const domainPattern = /^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
          const domains = this.adminConfig.domains
            .filter(d => d.domain?.trim())
            .map(d => ({ domain: d.domain.trim(), published: d.published || false }));
          const invalidDomains = domains.filter(d => !domainPattern.test(d.domain));
          if (invalidDomains.length > 0) {
            this.showError('Invalid domain format: ' + invalidDomains.map(d => d.domain).join(', '));
            return;
          }
          const res = await fetch('/api/admin-config/domains', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ domains })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('Admin domains updated successfully!');
          this.loadAdminConfig();
        } catch (err) {
          this.showError('Error updating admin domains: ' + err.message);
        }
      },
      
      async publishAdmin() {
        this.loading.admin = true;
        try {
          const res = await fetch('/api/admin-config/publish', { method: 'POST' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess(data.message);
          this.loadAdminConfig();
        } catch (err) {
          this.showError('Error publishing admin: ' + err.message);
        } finally {
          this.loading.admin = false;
        }
      },
      
      async unpublishAdmin() {
        this.loading.admin = true;
        try {
          const res = await fetch('/api/admin-config/unpublish', { method: 'POST' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess(data.message);
          this.loadAdminConfig();
        } catch (err) {
          this.showError('Error unpublishing admin: ' + err.message);
        } finally {
          this.loading.admin = false;
        }
      },
      
      // Migration
      async runMigration() {
        this.loading.migration = true;
        try {
          const res = await fetch('/api/migration/rbac', { method: 'POST' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess(data.message);
          await this.loadOrganizations();
          this.initCurrentOrganization();
          await this.loadLandings();
        } catch (err) {
          this.showError('Error running migration: ' + err.message);
        } finally {
          this.loading.migration = false;
        }
      },
      
      // Version Migration
      async runVersionMigration() {
        this.loading.versionMigration = true;
        try {
          const res = await fetch('/api/migration/versions', { method: 'POST' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess(data.message);
          await this.loadLandings();
        } catch (err) {
          this.showError('Error running version migration: ' + err.message);
        } finally {
          this.loading.versionMigration = false;
        }
      },
      
      // Move Landing
      openMoveModal(landing) {
        this.movingLanding = landing;
        this.moveTargetOrgId = '';
        this.showMoveModal = true;
      },
      
      async moveLanding() {
        this.loading.move = true;
        try {
          const res = await fetch('/api/migration/move-landing', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ landingId: this.movingLanding.id, targetOrganizationId: this.moveTargetOrgId })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess(data.message);
          this.showMoveModal = false;
          this.loadLandings();
        } catch (err) {
          this.showError('Error moving landing: ' + err.message);
        } finally {
          this.loading.move = false;
        }
      },
      
      // Organizations Management (Admin)
      async createOrganization() {
        try {
          const res = await fetch('/api/organizations', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: this.newOrgName })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('Organization created!');
          this.newOrgName = '';
          await this.loadOrganizations();
        } catch (err) {
          this.showError('Error creating organization: ' + err.message);
        }
      },
      
      async saveOrganization() {
        try {
          const res = await fetch(`/api/organizations/${this.editingOrg.id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: this.editingOrg.name })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('Organization updated!');
          this.editingOrg = null;
          await this.loadOrganizations();
        } catch (err) {
          this.showError('Error updating organization: ' + err.message);
        }
      },
      
      async deleteOrganization(id) {
        try {
          const res = await fetch(`/api/organizations/${id}`, { method: 'DELETE' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('Organization deleted!');
          await this.loadOrganizations();
        } catch (err) {
          this.showError('Error deleting organization: ' + err.message);
        }
      },
      
      // Users Management (Admin)
      async loadAllUsers() {
        try {
          const res = await fetch('/api/users');
          this.allUsers = await res.json();
        } catch (err) {
          console.error('Error loading users:', err);
        }
      },
      
      async loadAvailableRights() {
        try {
          const res = await fetch('/api/users/rights');
          this.availableRights = await res.json();
        } catch (err) {
          console.error('Error loading rights:', err);
        }
      },
      
      async createUser() {
        try {
          const res = await fetch('/api/users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: this.newUserEmail, password: this.newUserPassword })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('User created!');
          this.newUserEmail = '';
          this.newUserPassword = '';
          await this.loadAllUsers();
        } catch (err) {
          this.showError('Error creating user: ' + err.message);
        }
      },
      
      async deleteUser(email) {
        try {
          const res = await fetch(`/api/users/${encodeURIComponent(email)}`, { method: 'DELETE' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('User deleted!');
          await this.loadAllUsers();
          await this.loadOrganizations();
        } catch (err) {
          this.showError('Error deleting user: ' + err.message);
        }
      },
      
      availableUsersForOrg(org) {
        const orgUserEmails = org.users?.map(u => u.email) || [];
        return this.allUsers.filter(u => !orgUserEmails.includes(u.email));
      },
      
      async addUserToOrganization(orgId) {
        try {
          const res = await fetch(`/api/organizations/${orgId}/users`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: this.addUserEmail, rights: [] })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('User added to organization!');
          this.showAddUserToOrg = null;
          this.addUserEmail = '';
          await this.loadOrganizations();
        } catch (err) {
          this.showError('Error adding user: ' + err.message);
        }
      },
      
      async removeUserFromOrganization(orgId, email) {
        try {
          const res = await fetch(`/api/organizations/${orgId}/users/${encodeURIComponent(email)}`, { method: 'DELETE' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('User removed from organization!');
          await this.loadOrganizations();
        } catch (err) {
          this.showError('Error removing user: ' + err.message);
        }
      },
      
      openUserRightsModal(org, user) {
        this.editingUserRights = {
          orgId: org.id,
          orgName: org.name,
          email: user.email,
          rights: [...(user.rights || [])]
        };
        this.showUserRightsModal = true;
      },
      
      selectAllRights() { this.editingUserRights.rights = [...this.availableRights]; },
      selectNoRights() { this.editingUserRights.rights = []; },
      
      async saveUserRights() {
        try {
          const res = await fetch(`/api/organizations/${this.editingUserRights.orgId}/users/${encodeURIComponent(this.editingUserRights.email)}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ rights: this.editingUserRights.rights })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('Rights updated!');
          this.showUserRightsModal = false;
          await this.loadOrganizations();
        } catch (err) {
          this.showError('Error updating rights: ' + err.message);
        }
      },
      
      // File handling
      handleEjsFilesChange(event) {
        this.selectedEjsFiles = Array.from(event.target.files);
        this.selectedEjsZip = null;
        if (this.$refs.ejsZipInput) this.$refs.ejsZipInput.value = '';
      },
      handleEjsZipChange(event) {
        this.selectedEjsZip = event.target.files[0] || null;
        this.selectedEjsFiles = [];
        if (this.$refs.ejsFileInput) this.$refs.ejsFileInput.value = '';
      },
      handleEditEjsFilesChange(event) {
        this.editSelectedEjsFiles = Array.from(event.target.files);
        this.editSelectedEjsZip = null;
        if (this.$refs.editEjsZipInput) this.$refs.editEjsZipInput.value = '';
      },
      handleEditEjsZipChange(event) {
        this.editSelectedEjsZip = event.target.files[0] || null;
        this.editSelectedEjsFiles = [];
        if (this.$refs.editEjsFileInput) this.$refs.editEjsFileInput.value = '';
      },
      
      // Logout
      async logout() {
        try {
          await fetch('/api/logout');
        } catch (err) {
          console.log('Logout request completed');
        }
        window.location.href = '/login';
      },
      
      // Versions
      async openVersionsModal(landing) {
        this.versionLanding = landing;
        this.versions = [];
        this.newVersionDescription = '';
        this.showVersionsModal = true;
        await this.loadVersions();
      },
      
      closeVersionsModal() {
        this.showVersionsModal = false;
        this.versionLanding = null;
        this.versions = [];
      },
      
      async loadVersions() {
        if (!this.versionLanding) return;
        this.loading.versions = true;
        try {
          const res = await fetch(`/api/landings/${this.versionLanding.id}/versions`);
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || 'Failed to load versions');
          this.versions = data;
        } catch (err) {
          this.showError('Error loading versions: ' + err.message);
          this.versions = [];
        } finally {
          this.loading.versions = false;
        }
      },
      
      async createSnapshot() {
        this.loading.createVersion = true;
        try {
          const res = await fetch(`/api/landings/${this.versionLanding.id}/versions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ description: this.newVersionDescription || 'Manual snapshot' })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('Snapshot created!');
          this.newVersionDescription = '';
          await this.loadVersions();
        } catch (err) {
          this.showError('Error creating snapshot: ' + err.message);
        } finally {
          this.loading.createVersion = false;
        }
      },
      
      async previewVersion(version) {
        try {
          const res = await fetch(`/api/landings/${this.versionLanding.id}/versions/${version.id}/preview`);
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.previewingVersion = version;
          this.versionPreviewContent = data.content;
          this.showVersionPreviewModal = true;
        } catch (err) {
          this.showError('Error loading preview: ' + err.message);
        }
      },
      
      async viewVersionHtml(version) {
        const loadingKey = 'html-' + version.id;
        this.loading[loadingKey] = true;
        try {
          const res = await fetch(`/api/landings/${this.versionLanding.id}/versions/${version.id}/preview`);
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.viewingHtmlVersion = version;
          this.versionHtmlContent = data.content;
          this.showVersionHtmlModal = true;
        } catch (err) {
          this.showError('Error loading HTML: ' + err.message);
        } finally {
          this.loading[loadingKey] = false;
        }
      },
      
      async copyVersionHtml() {
        try {
          await navigator.clipboard.writeText(this.versionHtmlContent);
          this.showSuccess('HTML copied to clipboard!');
        } catch (err) {
          this.showError('Failed to copy: ' + err.message);
        }
      },
      
      async rollbackToVersion(version) {
        this.confirmingVersion = version;
        this.showRollbackConfirm = true;
      },
      
      async confirmRollback() {
        if (!this.confirmingVersion) return;
        
        const loadingKey = 'rollback-' + this.confirmingVersion.id;
        this.loading[loadingKey] = true;
        this.showRollbackConfirm = false;
        
        try {
          const res = await fetch(`/api/landings/${this.versionLanding.id}/versions/${this.confirmingVersion.id}/rollback`, { method: 'POST' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess(data.message);
          await this.loadVersions();
          await this.loadLandings();
        } catch (err) {
          this.showError('Error rolling back: ' + err.message);
        } finally {
          this.loading[loadingKey] = false;
          this.confirmingVersion = null;
        }
      },
      
      async deleteVersionItem(version) {
        this.confirmingVersion = version;
        this.showDeleteConfirm = true;
      },
      
      async confirmDelete() {
        if (!this.confirmingVersion) return;
        
        const loadingKey = 'delete-' + this.confirmingVersion.id;
        this.loading[loadingKey] = true;
        this.showDeleteConfirm = false;
        
        try {
          const res = await fetch(`/api/landings/${this.versionLanding.id}/versions/${this.confirmingVersion.id}`, { method: 'DELETE' });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.showSuccess('Version deleted!');
          await this.loadVersions();
        } catch (err) {
          this.showError('Error deleting version: ' + err.message);
        } finally {
          this.loading[loadingKey] = false;
          this.confirmingVersion = null;
        }
      },
      
      formatVersionDate(dateStr) {
        if (!dateStr) return '';
        return new Date(dateStr).toLocaleString();
      },
      
      formatBytes(bytes) {
        if (!bytes) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
      },
      
      // Version editing
      startEditDescription(version) {
        this.editingVersionId = version.id;
        this.tempDescription = version.description || '';
        this.editingVersionDescription = true;
        this.$nextTick(() => {
          const input = this.$refs[`desc-input-${version.id}`][0];
          if (input) input.focus();
        });
      },
      
      async saveDescription() {
        if (!this.editingVersionId) return;
        
        try {
          const res = await fetch(`/api/landings/${this.versionLanding.id}/versions/${this.editingVersionId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ description: this.tempDescription })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          
          this.showSuccess('Description updated!');
          await this.loadVersions();
          this.cancelEditDescription();
        } catch (err) {
          this.showError('Error updating description: ' + err.message);
        }
      },
      
      cancelEditDescription() {
        this.editingVersionDescription = false;
        this.editingVersionId = null;
        this.tempDescription = '';
      },
      
      startEditTag(version) {
        this.editingVersionId = version.id;
        this.tempTag = version.tag || '';
        this.editingVersionTag = true;
        this.$nextTick(() => {
          const input = this.$refs[`tag-input-${version.id}`][0];
          if (input) input.focus();
        });
      },
      
      async saveTag() {
        if (!this.editingVersionId) return;
        
        try {
          const res = await fetch(`/api/landings/${this.versionLanding.id}/versions/${this.editingVersionId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tag: this.tempTag.trim() || null })
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          
          this.showSuccess('Tag updated!');
          await this.loadVersions();
          this.cancelEditTag();
        } catch (err) {
          this.showError('Error updating tag: ' + err.message);
        }
      },
      
      cancelEditTag() {
        this.editingVersionTag = false;
        this.editingVersionId = null;
        this.tempTag = '';
      },
      
      removeTag(version) {
        this.editingVersionId = version.id;
        this.tempTag = null;
        this.saveTag();
      },
      
      // Diff
      async openDiffModal(version) {
        const loadingKey = 'diff-' + version.id;
        this.loading[loadingKey] = true;
        this.loading.diff = true;
        try {
          const res = await fetch(`/api/landings/${this.versionLanding.id}/versions/${version.id}/diff`);
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          
          this.diffData = data;
          // Collapse files with many changes by default (>50 lines)
          this.collapsedFiles = {};
          if (data.diffs) {
            data.diffs.forEach((diff, idx) => {
              const totalChanges = this.countChangesNum(diff);
              if (totalChanges > 50) {
                this.collapsedFiles[idx] = true;
              }
            });
          }
          this.showDiffModal = true;
        } catch (err) {
          this.showError('Error loading diff: ' + err.message);
        } finally {
          this.loading[loadingKey] = false;
          this.loading.diff = false;
        }
      },
      
      closeDiffModal() {
        this.showDiffModal = false;
        this.diffData = null;
        this.collapsedFiles = {};
      },
      
      toggleFileDiff(fileIdx) {
        this.collapsedFiles[fileIdx] = !this.collapsedFiles[fileIdx];
      },
      
      toggleAllFiles() {
        const allCollapsed = this.allFilesCollapsed;
        if (this.diffData?.diffs) {
          this.diffData.diffs.forEach((_, idx) => {
            this.collapsedFiles[idx] = !allCollapsed;
          });
        }
      },
      
      countChanges(fileDiff) {
        if (fileDiff.type === 'added') {
          const lines = fileDiff.hunks.reduce((sum, h) => sum + (h.newLines?.length || 0), 0);
          return `+${lines} lines`;
        }
        if (fileDiff.type === 'deleted') {
          const lines = fileDiff.hunks.reduce((sum, h) => sum + (h.oldLines?.length || 0), 0);
          return `-${lines} lines`;
        }
        let added = 0, removed = 0;
        fileDiff.hunks.forEach(h => {
          h.changes?.forEach(c => {
            if (c.type === 'add') added++;
            if (c.type === 'remove') removed++;
          });
        });
        return `+${added} -${removed}`;
      },
      
      countChangesNum(fileDiff) {
        if (fileDiff.type === 'added') {
          return fileDiff.hunks.reduce((sum, h) => sum + (h.newLines?.length || 0), 0);
        }
        if (fileDiff.type === 'deleted') {
          return fileDiff.hunks.reduce((sum, h) => sum + (h.oldLines?.length || 0), 0);
        }
        let total = 0;
        fileDiff.hunks.forEach(h => {
          h.changes?.forEach(c => {
            if (c.type === 'add' || c.type === 'remove') total++;
          });
        });
        return total;
      },
      
      // Audit
      async openAuditModal(landing) {
        this.auditLanding = landing;
        this.auditEntries = [];
        this.auditTotal = 0;
        this.auditHasMore = false;
        this.auditOffset = 0;
        this.showAuditModal = true;
        await this.loadAuditLog();
      },
      
      closeAuditModal() {
        this.showAuditModal = false;
        this.auditLanding = null;
        this.auditEntries = [];
        this.auditTotal = 0;
        this.auditHasMore = false;
        this.auditOffset = 0;
      },
      
      async loadAuditLog() {
        if (!this.auditLanding) return;
        this.loading.audit = true;
        try {
          const res = await fetch(`/api/landings/${this.auditLanding.id}/audit?limit=50&offset=${this.auditOffset}`);
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.auditEntries = data.entries;
          this.auditTotal = data.total;
          this.auditHasMore = data.hasMore;
        } catch (err) {
          this.showError('Error loading audit log: ' + err.message);
        } finally {
          this.loading.audit = false;
        }
      },
      
      async loadMoreAudit() {
        if (!this.auditLanding || !this.auditHasMore) return;
        this.loading.auditMore = true;
        try {
          this.auditOffset += 50;
          const res = await fetch(`/api/landings/${this.auditLanding.id}/audit?limit=50&offset=${this.auditOffset}`);
          const data = await res.json();
          if (!res.ok) throw new Error(data.error);
          this.auditEntries = [...this.auditEntries, ...data.entries];
          this.auditHasMore = data.hasMore;
        } catch (err) {
          this.showError('Error loading more audit entries: ' + err.message);
        } finally {
          this.loading.auditMore = false;
        }
      },
      
      formatAuditDate(dateStr) {
        if (!dateStr) return '';
        return new Date(dateStr).toLocaleString();
      },
      
      formatAuditAction(action) {
        const actionLabels = {
          'create': 'Created',
          'update': 'Updated',
          'delete': 'Deleted',
          'publish': 'Published',
          'unpublish': 'Unpublished',
          'rollback': 'Rollback',
          'version_create': 'Snapshot',
          'version_delete': 'Version Deleted',
          'version_tag': 'Tagged',
          'version_untag': 'Untagged',
          'domain_add': 'Domain Added',
          'domain_remove': 'Domain Removed',
          'domain_publish': 'Domain Published',
          'domain_unpublish': 'Domain Unpublished',
          'move': 'Moved'
        };
        return actionLabels[action] || action;
      },
      
      getAuditActionClass(action) {
        const classes = {
          'create': 'bg-green-100 text-green-700',
          'update': 'bg-blue-100 text-blue-700',
          'delete': 'bg-red-100 text-red-700',
          'publish': 'bg-emerald-100 text-emerald-700',
          'unpublish': 'bg-orange-100 text-orange-700',
          'rollback': 'bg-amber-100 text-amber-700',
          'version_create': 'bg-purple-100 text-purple-700',
          'version_delete': 'bg-red-100 text-red-700',
          'version_tag': 'bg-teal-100 text-teal-700',
          'version_untag': 'bg-gray-100 text-gray-700',
          'domain_add': 'bg-cyan-100 text-cyan-700',
          'domain_remove': 'bg-rose-100 text-rose-700',
          'domain_publish': 'bg-emerald-100 text-emerald-700',
          'domain_unpublish': 'bg-orange-100 text-orange-700',
          'move': 'bg-indigo-100 text-indigo-700'
        };
        return classes[action] || 'bg-gray-100 text-gray-700';
      },
      
      getVersionNumber(versionId) {
        if (!this.versions || !versionId) return '?';
        const version = this.versions.find(v => v.id === versionId);
        return version ? version.versionNumber : '?';
      },
      
      async viewLinkedVersion(versionId) {
        if (!this.auditLanding) return;
        
        try {
          // Close audit modal and open versions modal with the linked version visible
          this.closeAuditModal();
          
          // Open versions modal
          this.versionLanding = this.auditLanding;
          this.versions = [];
          this.newVersionDescription = '';
          this.showVersionsModal = true;
          
          // Load versions and scroll to the linked one
          await this.loadVersions();
          
          // Scroll to the version in the modal
          this.$nextTick(() => {
            const versionElement = document.querySelector(`[data-version-id="${versionId}"]`);
            if (versionElement) {
              versionElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
              versionElement.classList.add('ring-2', 'ring-yellow-400');
              setTimeout(() => versionElement.classList.remove('ring-2', 'ring-yellow-400'), 3000);
            }
          });
        } catch (err) {
          this.showError('Error loading version: ' + err.message);
        }
      },
      
      // Preview dirty changes
      previewDirtyChanges(mode = 'modal') {
        if (!this.editingLanding) return;
        
        // Get the current content from the editor
        let content = this.editingLanding.content;
        if (this.editEditor) {
          content = this.editEditor.getValue();
        }
        
        if (!content || content.trim() === '') {
          this.showError('No content to preview');
          return;
        }
        
        this.previewContent = content;
        this.previewMode = mode;
        
        if (mode === 'modal') {
          this.showPreviewModal = true;
        } else if (mode === 'tab') {
          this.openPreviewInNewTab(content);
        }
      },
      
      openPreviewInNewTab(content) {
        const blob = new Blob([content], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        window.open(url, '_blank');
        // Clean up the URL after a short delay
        setTimeout(() => URL.revokeObjectURL(url), 100);
      },
      
      closePreviewModal() {
        this.showPreviewModal = false;
        this.previewContent = '';
      },
      
      // Editors
      initAddEditor() {
        if (this.$refs.addEditorContainer && !this.addEditor) {
          const textarea = document.createElement('textarea');
          textarea.value = this.newLanding.content;
          this.$refs.addEditorContainer.appendChild(textarea);
          this.addEditor = CodeMirror.fromTextArea(textarea, { mode: 'htmlmixed', lineNumbers: true, theme: 'default', lineWrapping: true });
        }
      },
      initEditEditor() {
        if (this.$refs.editEditorContainer && !this.editEditor) {
          const textarea = document.createElement('textarea');
          textarea.value = this.editingLanding.content;
          this.$refs.editEditorContainer.appendChild(textarea);
          this.editEditor = CodeMirror.fromTextArea(textarea, { 
            mode: 'htmlmixed', 
            lineNumbers: true, 
            theme: 'default', 
            lineWrapping: true,
            extraKeys: {
              "Ctrl-F": "findPersistent",
              "F3": "findNext",
              "Ctrl-G": "findNext",
              "Shift-Ctrl-G": "findPrev",
              "Shift-F3": "findPrev"
            }
          });
          this.editEditor.setSize('100%', '100%');
        }
      }
    },
    watch: {
      showAddModal(val) {
        if (val) this.$nextTick(() => this.initAddEditor());
      },
      async showOrganizationsModal(val) {
        if (val) {
          await this.loadOrganizations();
          if (this.authInfo.isAdmin) {
            await this.loadAllUsers();
          }
        }
      }
    }
  }).mount('#app');
</script>
